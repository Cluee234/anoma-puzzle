<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Anoma Puzzle + Quiz ‚Äî Secret Number & Quiz</title>
<style>
  :root{
    --anoma-red:#ff2b2b;
    --bg:#070707;
    --card:#131313;
    --muted:#dcdcdc;
    --white:#ffffff;
    --accent:#ffdede;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, Arial, sans-serif;color:var(--white);display:flex;align-items:center;justify-content:center;padding:18px;}
  .app{width:100%;max-width:980px;}
  .card{background:linear-gradient(180deg, rgba(255,43,43,0.03), rgba(0,0,0,0.22)), var(--card);border:1px solid rgba(255,43,43,0.12);border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.7);padding:22px;}
  header{display:flex;align-items:center;gap:12px;margin-bottom:6px;}
  h1{margin:0;color:var(--anoma-red);font-size:1.25rem;}
  .lead{margin:0;color:var(--muted);font-size:0.95rem;margin-bottom:6px;}
  .mode-select{display:flex;gap:12px;align-items:center;margin-bottom:16px;}
  .mode-btn{flex:1;padding:14px;border-radius:12px;border:1px solid rgba(255,43,43,0.12);background:linear-gradient(180deg, rgba(255,43,43,0.06), rgba(0,0,0,0.12));color:var(--white);font-weight:800;cursor:pointer;}
  .mode-btn:hover{opacity:0.95}
  .hidden{display:none}
  /* Puzzle styles (kept from original) */
  .timer-wrap{height:12px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;margin:14px 0 10px;position:relative;}
  .timer-bar{height:100%;background:linear-gradient(90deg,var(--anoma-red), #ff7b7b);width:100%;transition:width 0.9s linear;}
  #timerLabel{margin-bottom:12px;font-weight:700;color:#ffdede;}
  .top-stats{display:flex;gap:14px;align-items:center;margin-bottom:12px;color:#ffdede;font-weight:600;}
  .small{font-weight:500;color:#f7dcdc;font-size:0.95rem;}
  .questions{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:12px;}
  .hint-btn{padding:10px 14px;border-radius:10px;border:none;background:var(--anoma-red);color:#111;font-weight:700;cursor:pointer;min-width:170px;flex:1 1 calc(33% - 10px);transition: filter 0.3s ease;}
  .hint-btn:hover:not(:disabled){opacity:0.85;}
  .hint-btn:disabled{cursor:not-allowed;}
  .clues{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;min-height:70px;color:var(--muted);margin-bottom:12px;overflow:auto; display: flex; flex-direction: column-reverse;}
  .controls{display:flex;gap:10px;align-items:center;margin-bottom:8px;}
  input[type="number"]{flex:1;padding:10px 12px;border-radius:10px;border:2px solid rgba(255,43,43,0.12);background:#100606;color:var(--white);font-size:1rem;}
  #submitBtn{padding:10px 14px;border-radius:10px;border:none;background:var(--anoma-red);color:#111;font-weight:700;cursor:pointer;}
  #submitBtn:disabled{opacity:0.6;cursor:not-allowed;}
  #message{margin-top:10px;font-weight:700;min-height:40px;}
  #tryBtn{display:none;margin-top:12px;padding:8px 12px;border-radius:10px;border:1px solid rgba(255,43,43,0.14);background:#111;color:var(--anoma-red);cursor:pointer;font-weight:700;}
  #restartBtn{display:none;margin-top:12px;padding:10px 14px;border-radius:10px;border:none;background:#ff4a4a;color:#111;cursor:pointer;font-weight:700;}
  .footer-note{font-size:0.85rem;color:#d9d9d9;margin-top:10px}
  /* Quiz styles */
  .quiz-wrap{margin-top:12px}
  .question-card{background:rgba(255,255,255,0.02);padding:16px;border-radius:12px;margin-bottom:12px}
  .answers{display:flex;flex-direction:column;gap:10px}
  .ans-btn{padding:10px 12px;border-radius:10px;border:1px solid rgba(255,43,43,0.12);background:#111;text-align:left;color:var(--white);cursor:pointer}
  .ans-btn[disabled]{opacity:0.6;cursor:not-allowed}
  .quiz-top{display:flex;gap:12px;align-items:center;margin-bottom:10px}
  .progress{height:10px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden;flex:1}
  .progress-bar{height:100%;background:linear-gradient(90deg,var(--anoma-red), #ff7b7b);width:100%;transition:width 0.3s linear}
  .quiz-stats{font-weight:700;color:var(--accent)}
  @media (max-width:640px){ .hint-btn{flex:1 1 100%;min-width:0;} .controls{flex-direction:column;} #submitBtn{width:100%;} }
</style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header><h1>üîÆ Anoma ‚Äî Puzzle & Quiz</h1><div style="flex:1"></div></header>
      <p class="lead">Choose a mode: keep your puzzle rounds or test your Anoma & Web3 knowledge with a 10-question quiz (15s each).</p>

      <div class="mode-select">
        <button id="puzzleModeBtn" class="mode-btn">üß© Puzzle Mode</button>
        <button id="quizModeBtn" class="mode-btn">‚ùì Quiz Mode (10 Qs)</button>
      </div>

      <!-- PUZZLE CONTAINER (kept logic identical but exposed via PuzzleAPI) -->
      <div id="puzzleContainer">
        <div class="timer-wrap" aria-hidden="true"><div id="timerBar" class="timer-bar"></div></div>
        <div id="timerLabel">Time left: <span id="timeLeft">50</span>s</div>

        <div class="top-stats">
          <div class="small">Rounds: <span id="attemptsCount">0</span></div>
          <div class="small">Score: <span id="scoreCount">0</span></div>
          <div style="flex:1"></div>
        </div>

        <div class="questions" role="group" aria-label="Hint buttons">
          <button class="hint-btn" data-type="evenOdd">Even / Odd</button>
          <button class="hint-btn" data-type="div2">Divisible by 2</button>
          <button class="hint-btn" data-type="div3">Divisible by 3</button>
          <button class="hint-btn" data-type="prime">Prime?</button>
          <button class="hint-btn" data-type="gt20">Greater than 20?</button>
          <button class="hint-btn" data-type="gt50">Greater than 50?</button>
        </div>

        <div class="clues" id="clues" aria-live="polite"><em>No hints yet ‚Äî click a hint above.</em></div>

        <div class="controls">
          <input id="guessInput" type="number" min="1" max="100" placeholder="Enter your guess (1‚Äì100)" aria-label="Guess number" />
          <button id="submitBtn">Submit Guess</button>
        </div>

        <div id="message" role="status" aria-live="polite"></div>
        <button id="tryBtn">üîÑ New Round</button>
        <button id="restartBtn">‚ôªÔ∏è Restart Game</button>
        <div class="footer-note">Hints disable after one use per round. Sounds play on success/failure (allow audio in browser).</div>

        <!-- sounds -->
        <audio id="successAudio" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
        <audio id="failAudio" src="https://actions.google.com/sounds/v1/cartoon/boing.ogg" preload="auto"></audio>
      </div>

      <!-- QUIZ CONTAINER -->
      <div id="quizContainer" class="hidden">
        <div class="quiz-top">
          <div class="quiz-stats">Question <span id="qIndex">0</span>/10</div>
          <div class="progress"><div id="quizProgressBar" class="progress-bar"></div></div>
          <div class="quiz-stats">Score: <span id="quizScore">0</span></div>
        </div>

        <div id="quizCard" class="question-card">
          <div id="quizQuestion">Loading question...</div>
          <div class="answers" id="quizAnswers"></div>
        </div>

        <div style="display:flex;gap:10px;align-items:center;">
          <button id="quizNextBtn" class="mode-btn">Next</button>
          <button id="quizRestartBtn" class="mode-btn">Restart Quiz</button>
          <div style="flex:1"></div>
          <div class="small" id="quizTimerLabel">Time left: <span id="quizTimeLeft">15</span>s</div>
        </div>
      </div>

    </div>
  </div>

<script>
// ---------------- P U Z Z L E   L O G I C  (adapted & exposed) ----------------
(function(){
  const RANGE_MIN = 1, RANGE_MAX = 100;
  const START_SECONDS = 50;
  const MAX_HINTS_PER_ROUND = 5;
  const MAX_ROUNDS = 3;

  let secret = null;
  let timeLeft = START_SECONDS;
  let timerId = null;
  let usedHints = new Set();
  let hintsUsedCount = 0;
  let score = 0;
  let rounds = 0;

  const timerBar = document.getElementById('timerBar');
  const timeLabel = document.getElementById('timeLeft');
  const attemptsEl = document.getElementById('attemptsCount');
  const scoreEl = document.getElementById('scoreCount');
  const hintBtns = Array.from(document.querySelectorAll('.hint-btn'));
  const cluesEl = document.getElementById('clues');
  const guessInput = document.getElementById('guessInput');
  const submitBtn = document.getElementById('submitBtn');
  const messageEl = document.getElementById('message');
  const tryBtn = document.getElementById('tryBtn');
  const restartBtn = document.getElementById('restartBtn');
  const successAudio = document.getElementById('successAudio');
  const failAudio = document.getElementById('failAudio');

  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function isPrime(n){ if(n<2)return false; for(let i=2;i<=Math.sqrt(n);i++) if(n%i===0) return false; return true; }
  function setMessage(text, tone){
    messageEl.textContent = text;
    if(tone==='ok') messageEl.style.color = '#c8ffd8';
    else if(tone==='warn') messageEl.style.color = '#ffdca3';
    else if(tone==='err') messageEl.style.color = '#ffb3b3';
    else messageEl.style.color = '#fff';
  }

  function renderStats(){
    attemptsEl.textContent = String(rounds);
    scoreEl.textContent = String(score);
  }

  function renderHints(){
    hintBtns.forEach(btn => {
      const t = btn.dataset.type;
      if(usedHints.has(t)){
        btn.disabled = true;
        btn.style.display = 'none';
        btn.style.filter = 'none';
      } else {
        btn.style.display = '';
        btn.disabled = false;
        btn.style.filter = 'none';
      }
    });

    if(hintsUsedCount >= MAX_HINTS_PER_ROUND){
      const leftover = hintBtns.filter(b => !usedHints.has(b.dataset.type));
      if(leftover.length === 1){
        leftover[0].disabled = true;
        leftover[0].style.filter = 'blur(2px)';
        leftover[0].style.display = '';
      } else if(leftover.length > 1){
        leftover.forEach(b => {
          b.disabled = true;
          b.style.filter = 'blur(2px)';
          b.style.display = '';
        });
      }
    }

    if(hintsUsedCount === 0){
      if(!cluesEl.querySelector('em')){
        cluesEl.innerHTML = '<em>No hints yet ‚Äî click a hint above.</em>';
      }
    }
  }

  function renderTimer(){
    const pct = Math.max(0, (timeLeft / START_SECONDS) * 100);
    timerBar.style.width = pct + '%';
    timeLabel.textContent = String(timeLeft);
  }

  function startRound(){
    if(rounds >= MAX_ROUNDS){
      setMessage(`üèÜ Game over! Your total score: ${score} / ${MAX_ROUNDS}. Click "Restart Game" to play again.`, 'ok');
      guessInput.disabled = true; submitBtn.disabled = true;
      hintBtns.forEach(b => { b.disabled = true; b.style.display = 'none'; b.style.filter = 'none'; });
      tryBtn.style.display = 'none';
      restartBtn.style.display = 'inline-block';
      return;
    }

    secret = randInt(RANGE_MIN, RANGE_MAX);
    usedHints.clear();
    hintsUsedCount = 0;
    timeLeft = START_SECONDS;
    clearInterval(timerId);
    timerId = setInterval(tick, 1000);
    guessInput.disabled = false; submitBtn.disabled = false;
    tryBtn.style.display = 'none';
    restartBtn.style.display = 'none';
    cluesEl.innerHTML = '<em>No hints yet ‚Äî click a hint above.</em>';
    setMessage('', null);
    renderHints(); renderStats(); renderTimer();
    guessInput.value = '';
  }

  function endRound(won){
    clearInterval(timerId);
    rounds += 1;
    renderStats();
    guessInput.disabled = true; submitBtn.disabled = true;
    tryBtn.style.display = 'inline-block';

    if(won){
      setMessage('üéâ Correct ‚Äî round complete. Start a new round when ready.', 'ok');
      try{ successAudio.currentTime = 0; successAudio.play().catch(()=>{}); }catch(e){}
      score += 1;
      renderStats();
    } else {
      setMessage(`‚è≥ Time's up ‚Äî the number was ${secret}.`, 'err');
      try{ failAudio.currentTime = 0; failAudio.play().catch(()=>{}); }catch(e){}
    }
  }

  function tick(){
    timeLeft--;
    if(timeLeft < 0) timeLeft = 0;
    renderTimer();
    if(timeLeft <= 0) endRound(false);
  }

  function handleHint(type, btn){
    if(timeLeft <= 0) return;
    if(usedHints.has(type) || hintsUsedCount >= MAX_HINTS_PER_ROUND) return;

    let text = '';
    if(type === 'evenOdd') text = (secret % 2 === 0) ? 'It is even.' : 'It is odd.';
    else if(type === 'div2') text = (secret % 2 === 0) ? 'Yes ‚Äî divisible by 2.' : 'No ‚Äî not divisible by 2.';
    else if(type === 'div3') text = (secret % 3 === 0) ? 'Yes ‚Äî divisible by 3.' : 'No ‚Äî not divisible by 3.';
    else if(type === 'prime') text = isPrime(secret) ? 'Yes ‚Äî it is prime.' : 'No ‚Äî it is not prime.';
    else if(type === 'gt20') text = (secret > 20) ? 'Yes ‚Äî greater than 20.' : 'No ‚Äî 20 or below.';
    else if(type === 'gt50') text = (secret > 50) ? 'Yes ‚Äî greater than 50.' : 'No ‚Äî 50 or below.';

    // Remove only the <em> "No hints yet" on first hint click
    if(hintsUsedCount === 0){
      const noHintsEm = cluesEl.querySelector('em');
      if(noHintsEm) noHintsEm.remove();
    }

    const node = document.createElement('div');
    node.textContent = text;
    cluesEl.appendChild(node);

    usedHints.add(type);
    hintsUsedCount++;

    btn.disabled = true;
    btn.style.display = 'none';

    renderHints();
  }

  function submitGuess(){
    if(timeLeft <= 0) return;
    const val = parseInt(guessInput.value, 10);
    if(!val || val < RANGE_MIN || val > RANGE_MAX){
      setMessage(`Please enter a number between ${RANGE_MIN} and ${RANGE_MAX}.`, 'warn');
      try{ failAudio.currentTime = 0; failAudio.play().catch(()=>{}); }catch(e){}
      return;
    }
    if(val === secret){
      endRound(true);
    } else {
      setMessage(val < secret ? '‚ùå Too low ‚Äî try again.' : '‚ùå Too high ‚Äî try again.', 'warn');
      try{ failAudio.currentTime = 0; failAudio.play().catch(()=>{}); }catch(e){}
    }
  }

  function tryNewRound(){
    if(rounds < MAX_ROUNDS){
      startRound();
      setMessage('', null);
      tryBtn.style.display = 'none';
      restartBtn.style.display = 'none';
    }
  }

  function restartGame(){
    score = 0;
    rounds = 0;
    setMessage('', null);
    tryBtn.style.display = 'none';
    restartBtn.style.display = 'none';
    renderStats();
    startRound();
  }

  hintBtns.forEach(btn => { btn.addEventListener('click', () => handleHint(btn.dataset.type, btn)); });
  submitBtn.addEventListener('click', submitGuess);
  tryBtn.addEventListener('click', tryNewRound);
  restartBtn.addEventListener('click', restartGame);

  // expose API so we can start puzzle when user selects mode
  window.PuzzleAPI = { startRound, restartGame, tryNewRound };

  // NOTE: don't auto-start here ‚Äî will start when user picks Puzzle mode
})();

// ---------------- Q U I Z   L O G I C  ----------------
(function(){
  // We'll programmatically build 1,000 realistic Anoma/Web3 MCQs using templates.
  // This keeps the file compact while ensuring questions are embedded and realistic.
  const TOTAL_POOL = 1000;
  const QUESTIONS_PER_GAME = 10;
  const TIME_PER_Q = 15; // seconds

  const quizContainer = document.getElementById('quizContainer');
  const puzzleContainer = document.getElementById('puzzleContainer');
  const puzzleModeBtn = document.getElementById('puzzleModeBtn');
  const quizModeBtn = document.getElementById('quizModeBtn');

  const qIndexEl = document.getElementById('qIndex');
  const quizScoreEl = document.getElementById('quizScore');
  const quizQuestionEl = document.getElementById('quizQuestion');
  const quizAnswersEl = document.getElementById('quizAnswers');
  const quizProgressBar = document.getElementById('quizProgressBar');
  const quizTimeLeftEl = document.getElementById('quizTimeLeft');
  const quizNextBtn = document.getElementById('quizNextBtn');
  const quizRestartBtn = document.getElementById('quizRestartBtn');

  let pool = [];
  let gameQuestions = [];
  let currentIndex = 0;
  let score = 0;
  let timeLeft = TIME_PER_Q;
  let qTimerId = null;
  let accepting = false;

  // Templates & factual snippets to construct realistic-seeming questions
  const topics = [
    {key:'anoma', label:'Anoma', facts:[
      'focuses on privacy-preserving transactions',
      'uses UTXO-like constructs and nullifiers',
      'designs around account abstraction and privacy',
      'integrates zk proofs for private transfers'
    ]},
    {key:'zk', label:'Zero-knowledge proofs', facts:[
      'prove knowledge without revealing secrets',
      'include SNARKs and STARKs as common variants',
      'are used to compress on-chain verification work'
    ]},
    {key:'merkle', label:'Merkle trees', facts:[
      'allow compact proofs of membership',
      'are used to track UTXOs and states off-chain',
      'use hashing up the tree to a root used on-chain'
    ]},
    {key:'nullifier', label:'Nullifiers', facts:[
      'prevent double-spending in privacy systems',
      'are revealed when spending a UTXO to mark it spent'
    ]},
    {key:'consensus', label:'Consensus', facts:[
      'orders transactions and ensures finality',
      'Proof-of-Stake reduces energy compared to Proof-of-Work'
    ]},
    {key:'rollup', label:'Rollups', facts:[
      'batch transactions off-chain to scale L1',
      'have optimistic and zk variants'
    ]},
    {key:'crypto', label:'Cryptography', facts:[
      'uses asymmetric keys for signing transactions',
      'hash functions are irreversible and deterministic'
    ]},
    {key:'utxo', label:'UTXO', facts:[
      'stands for Unspent Transaction Output',
      'each UTXO can only be spent once using a nullifier'
    ]}
  ];

  const questionTemplates = [
    q=> ({
      q: `Which statement best describes ${q.topic.label}?`,
      choices: q.choices,
      answer: q.answer
    }),
    q=> ({
      q: `In the context of ${q.topic.label}, what is the primary purpose of ${q.focus}?`,
      choices: q.choices,
      answer: q.answer
    }),
    q=> ({
      q: `Which of the following is true about ${q.focus}?`,
      choices: q.choices,
      answer: q.answer
    }),
    q=> ({
      q: `How does ${q.topic.label} typically help with scalability or privacy?`,
      choices: q.choices,
      answer: q.answer
    })
  ];

  // utility to shuffle
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} }

  // build pool programmatically
  function buildPool(){
    const poolLocal = [];
    // We'll create multiple variants per topic/fact combo until we reach TOTAL_POOL
    let idx = 0;
    while(poolLocal.length < TOTAL_POOL){
      const t = topics[idx % topics.length];
      const fact = t.facts[idx % t.facts.length];

      // choose focus (a short phrase)
      const focus = (fact.split(' ')[0] || t.label).replace(/\./g,'');

      // craft plausible choices -- one correct, three distractors
      const correct = (()=>{
        if(fact.includes('privacy')) return `${t.label} enables privacy-preserving transfers.`;
        if(fact.includes('nullifier')) return `A nullifier marks a spent output to prevent double-spending.`;
        if(fact.includes('UTXO')) return `UTXO means unspent transaction output and is spent once.`;
        if(fact.includes('Merkle')) return `Merkle trees allow compact proofs of membership via a root hash.`;
        if(fact.includes('zk')) return `Zero-knowledge proofs let you prove something without revealing the secret.`;
        if(fact.includes('batch')||fact.includes('Rollups')||fact.includes('rollup')) return `Rollups batch transactions off-chain to reduce on-chain load.`;
        if(fact.includes('signing')||fact.includes('asymmetric')) return `Asymmetric keys are used to sign and authenticate transactions.`;
        if(fact.includes('finality')) return `Consensus protocols order transactions and provide finality.`;
        return fact; // fallback
      })();

      // distractors ‚Äî plausible but wrong
      const distractors = [];
      distractors.push(`It stores all user private keys on-chain.`);
      distractors.push(`It increases required gas for every simple transfer.`);
      distractors.push(`It automatically mints new tokens for each transaction.`);

      // now assemble choices and ensure correct is included
      const choices = [correct, distractors[0], distractors[1], distractors[2]];
      shuffle(choices);
      const answer = choices.indexOf(correct);

      poolLocal.push({
        q: `Topic: ${t.label} ‚Äî ${fact.charAt(0).toUpperCase()+fact.slice(1)}`,
        choices,
        answer
      });

      idx++;
      if(idx>5000) break; // safety
    }

    // if we didn't reach exact TOTAL_POOL (due to limited templates), fill with variations
    while(poolLocal.length < TOTAL_POOL){
      const i = poolLocal[poolLocal.length % poolLocal.length] || {q:'Fallback question', choices:['A','B','C','D'], answer:0};
      poolLocal.push(Object.assign({}, i));
    }

    // final shuffle for randomness
    shuffle(poolLocal);
    return poolLocal.slice(0, TOTAL_POOL);
  }

  // Build pool once on load
  pool = buildPool();

  // Pick QUESTIONS_PER_GAME unique random questions
  function pickGameQuestions(){
    const indices = Array.from({length:pool.length},(_,i)=>i);
    shuffle(indices);
    return indices.slice(0, QUESTIONS_PER_GAME).map(i => pool[i]);
  }

  function startQuiz(){
    gameQuestions = pickGameQuestions();
    currentIndex = 0; score = 0;
    qIndexEl.textContent = String(currentIndex+1);
    quizScoreEl.textContent = String(score);
    quizContainer.classList.remove('hidden');
    puzzleContainer.classList.add('hidden');
    renderQuestion();
  }

  function renderQuestion(){
    clearInterval(qTimerId);
    accepting = true;
    const q = gameQuestions[currentIndex];
    qIndexEl.textContent = String(currentIndex+1);
    quizQuestionEl.textContent = q.q;
    quizAnswersEl.innerHTML = '';
    q.choices.forEach((c, i)=>{
      const b = document.createElement('button');
      b.className = 'ans-btn';
      b.textContent = String.fromCharCode(65+i)+'. '+c;
      b.addEventListener('click', ()=> selectAnswer(i));
      quizAnswersEl.appendChild(b);
    });
    timeLeft = TIME_PER_Q;
    quizTimeLeftEl.textContent = String(timeLeft);
    updateProgress();
    qTimerId = setInterval(()=>{
      timeLeft--;
      if(timeLeft<0) timeLeft=0;
      quizTimeLeftEl.textContent = String(timeLeft);
      updateProgress();
      if(timeLeft<=0){
        clearInterval(qTimerId);
        accepting = false;
        revealAnswer(null);
      }
    },1000);
  }

  function updateProgress(){
    const pct = Math.max(0, (timeLeft / TIME_PER_Q) * 100);
    quizProgressBar.style.width = pct + '%';
  }

  function selectAnswer(index){
    if(!accepting) return;
    accepting = false;
    clearInterval(qTimerId);
    revealAnswer(index);
  }

  function revealAnswer(selected){
    const q = gameQuestions[currentIndex];
    const buttons = Array.from(quizAnswersEl.querySelectorAll('.ans-btn'));
    buttons.forEach((b, i)=>{
      b.disabled = true;
      if(i === q.answer){
        b.style.borderColor = 'rgba(0,200,120,0.6)';
        b.style.background = 'linear-gradient(90deg, rgba(0,200,120,0.06), rgba(0,0,0,0.12))';
      } else if(i === selected){
        b.style.borderColor = 'rgba(255,160,100,0.6)';
        b.style.background = 'linear-gradient(90deg, rgba(255,160,100,0.03), rgba(0,0,0,0.06))';
      }
    });

    if(selected === q.answer){ score++; quizScoreEl.textContent = String(score); }

    // show next after short delay (or user can click Next)
    setTimeout(()=>{
      // advance
      currentIndex++;
      if(currentIndex >= gameQuestions.length){
        finishQuiz();
      } else {
        renderQuestion();
      }
    }, 900);
  }

  function finishQuiz(){
    clearInterval(qTimerId);
    quizQuestionEl.textContent = `Quiz complete ‚Äî your score: ${score} / ${QUESTIONS_PER_GAME}`;
    quizAnswersEl.innerHTML = '';
    const restart = document.createElement('div');
    restart.innerHTML = `<div style="margin-top:8px;color:var(--accent)">Click Restart Quiz to play again or choose Puzzle Mode.</div>`;
    quizAnswersEl.appendChild(restart);
  }

  // UI bindings
  puzzleModeBtn.addEventListener('click', ()=>{
    quizContainer.classList.add('hidden');
    puzzleContainer.classList.remove('hidden');
    // start puzzle on demand
    try{ window.PuzzleAPI.startRound(); }catch(e){}
  });
  quizModeBtn.addEventListener('click', ()=>{
    startQuiz();
  });

  quizNextBtn.addEventListener('click', ()=>{
    if(!accepting){
      if(currentIndex < gameQuestions.length-1){ currentIndex++; renderQuestion(); }
      else finishQuiz();
    }
  });

  quizRestartBtn.addEventListener('click', ()=>{
    startQuiz();
  });

  // expose pool for debugging (optional)
  window._AnomaQuizPool = pool;

})();
</script>
</body>
</html>
